var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import engine from './engine';
var Status;
(function (Status) {
    Status["NEW"] = "NEW";
    Status["RUNNING"] = "RUNNING";
    Status["WAITING"] = "WAITING";
    Status["DONE"] = "DONE";
})(Status || (Status = {}));
class Coroutine {
    constructor(coBlock, config) {
        this.start = () => {
            this.run();
        };
        this.run = () => __awaiter(this, void 0, void 0, function* () {
            if (this.status === Status.RUNNING)
                return;
            this.status = Status.RUNNING;
            const sleep = this.sleep;
            const coSwitch = this.coSwitch;
            const park = this.park;
            yield this.coBlock({
                sleep, coSwitch, park
            });
            this.status = Status.DONE;
            engine.emit('delete', this);
        });
        this.coSwitch = () => {
            this.status = Status.WAITING;
            return new Promise(resolve => {
                engine.emit('continue', () => {
                    resolve();
                    this.status = Status.RUNNING;
                });
            });
        };
        this.sleep = (t = 0) => {
            this.status = Status.WAITING;
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve();
                    this.status = Status.RUNNING;
                }, t);
            });
        };
        this.park = () => {
            this.status = Status.WAITING;
            return new Promise(() => { });
        };
        this.status = Status.NEW;
        this.name = config && config.name;
        this.coBlock = coBlock;
        engine.emit('add', this);
        config && config.isStart && this.run();
    }
}
Coroutine.getCoroutines = () => {
    return engine.getCoroutines();
};
export { Coroutine as default, Coroutine };
